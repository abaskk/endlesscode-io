{
    "AC 自动机 = 字典树 + KMP。": "AC Automaton = Trie + KMP.",
    "由于这些题目也可以用其他算法（字符串哈希等）解决，难度分仅供参考。": "Since these problems can also be solved by other algorithms (String Hash, etc.), the difficulty rating is for reference only.",
    "AND 的数越多，结果越小。": "The more numbers you AND, the smaller the result.",
    "OR 的数越多，结果越大。": "The more numbers you OR, the larger the result.",
    "Dijkstra 算法介绍": "Introduction to Dijkstra Algorithm",
    "Floyd 算法本质是三维 DP。理解 DP 一定要基于空间优化前的写法。": "The essence of Floyd's algorithm is 3D DP. Understanding DP must be based on the unoptimized space version.",
    "带你发明 Floyd 算法：从记忆化搜索到递推": "Inventing Floyd's Algorithm: From Memoization to Iteration",
    "KMP 原理讲解": "KMP Principle Explanation",
    "定义 s 的真前缀为不等于 s 的前缀，s 的真后缀为不等于 s 的后缀。": "Define a proper prefix of s as a prefix not equal to s, and a proper suffix of s as a suffix not equal to s.",
    "定义 s 的 border 为既是 s 的真前缀又是 s 的真后缀的字符串。例如在 s=aabcaa 中，a 和 aa 都是 s 的 border。": "Define a border of s as a string that is both a proper prefix and a proper suffix of s. For example, in s=aabcaa, 'a' and 'aa' are borders.",
    "对于模式串 p 的每个前缀 p[:i]，计算这个前缀的最长 border 长度，记在 π 数组中。": "For each prefix p[:i] of pattern p, calculate the length of its longest border and store it in the π array.",
    "利用 π 数组，可以快速计算模式串 p 出现在文本串 t 的哪些位置上。": "Using the π array, we can quickly calculate the positions where pattern p appears in text t.",
    "注：π 数组的定义参考《算法导论》，国内数据结构教材通常定义为 next 数组。以严蔚敏那本为例，二者的关系是 next[i+1]=π[i]+1，即 π 数组整体右移一位，元素值加一。": "Note: The definition of the π array refers to CLRS. Common Chinese textbooks usually define it as the 'next' array. The relationship is often next[i+1]=π[i]+1.",
    "LogTrick 入门教程，包含原地写法，以及额外维护一个列表的写法。": "LogTrick Tutorial: Includes in-place implementation and list-maintenance implementation.",
    "如果你不熟悉原地去重算法，可以看 26. 删除有序数组中的重复项，我的题解。": "If you are not familiar with in-place deduplication, see my solution for 26. Remove Duplicates from Sorted Array.",
    "注：下面的部分题目，可以用滑动窗口+栈做到更优的 O(n) 时间复杂度，见 原理讲解（方法二）。": "Note: Some problems below can be solved with Sliding Window + Stack for better O(n) complexity. See Explanation (Method 2).",
    "Manacher 算法可以计算以 s[i]（或者 s[i] 和 s[i+1]）为回文中心的最长回文子串的长度。": "Manacher's Algorithm calculates the length of the longest palindromic substring centered at s[i] (or s[i] and s[i+1]).",
    "此外，还可以：": "In addition, it can also:",
    "ST 表 支持区间最值查询（Range Minimum/Maximum Query，RMQ），但不支持修改。": "ST Table supports Range Minimum/Maximum Query (RMQ) but does not support updates.",
    "优点是代码短，且查询的时间复杂度是 O(1)。所以作为补充内容，附在此处。": "Its advantage is short code and O(1) query complexity. Included here as supplementary content.",
    "“花费一个 log 的时间，增加了一个条件。” —— 二分答案": "\"Spend a log time to add a condition.\" — Binary Search on Answer.",
    "【图解】一张图秒懂二维前缀和": "[Visual] Understand 2D Prefix Sum in one image",
    "【图解】从一维差分到二维差分": "[Visual] From 1D Difference Array to 2D Difference Array",
    "【套路】教你解决定长滑窗！适用于所有定长滑窗题目！": "[Pattern] Master Fixed-Length Sliding Window! Applies to all such problems!",
    "一图掌握二分答案！四种写法！": "Master Binary Search on Answer in one image! Four templates!",
    "请注意「求最小」和「求最大」在二分写法上的区别。": "Note the difference in binary search templates for 'Find Minimum' and 'Find Maximum'.",
    "「求最小」和二分查找求「排序数组中某元素的第一个位置」是类似的，按照红蓝染色法，左边是不满足要求的（红色），右边则是满足要求的（蓝色）。": "'Find Minimum' is similar to finding 'First Position of Element'. Using Red-Blue coloring: Left is invalid (Red), Right is valid (Blue).",
    "「求最大」的题目则相反，左边是满足要求的（蓝色），右边是不满足要求的（红色）。这会导致二分写法和上面的「求最小」有一些区别。": "'Find Maximum' is the opposite: Left is valid (Blue), Right is invalid (Red). This leads to a slightly different binary search template.",
    "以开区间二分为例：": "Taking open-interval binary search as an example:",
    "一般定义 f[S] 表示未选（或者已选）的集合为 S 时，和题目有关的最优值。通过枚举 S（或者 S 的补集 ∁U​S）的子集来转移。": "Generally define f[S] as the optimal value when the unselected (or selected) set is S. Transition by enumerating subsets of S (or its complement).",
    "时间复杂度（通常来说）是 O(3n)，证明：": "Time complexity is usually O(3^n). Proof:",
    "对于大小为 n 的集合，它的大小为 m 的子集有 (mn​) 个，每个子集又有 2m 个子集。根据二项式定理，m=0∑n​(mn​)2m=(2+1)n=3n，所以「枚举子集的子集」的总体时间复杂度为 O(3n)。": "For a set of size n, there are C(n, m) subsets of size m, and each has 2^m subsets. By Binomial Theorem, sum(C(n,m)*2^m) = (2+1)^n = 3^n. So total complexity is O(3^n).",
    "注：某些网格图的题也可以用「选或不选」来做，从而减少状态个数，详见「§9.5 轮廓线 DP」。": "Note: Some grid problems can also be solved with 'Select or Not' to reduce states. See '§9.5 Broken Profile DP'.",
    "一般定义 f[S][i] 表示未选（或者已选）的集合为 S，且上一个填的元素（下标）为 i 时，和题目有关的最优值。通过枚举当前位置要填的元素（下标）来转移。": "Generally define f[S][i] as optimal value with set S and last filled element i. Transition by enumerating the next element to fill.",
    "时间复杂度（通常来说）是 O(n2⋅2n)。": "Time complexity is usually O(n^2 * 2^n).",
    "一般定义 f[i] 表示长为 i 的前缀 a[:i] 能否划分。": "Generally define f[i] as whether prefix a[:i] of length i can be partitioned.",
    "枚举最后一个子数组的左端点 L，从 f[L] 转移到 f[i]，并考虑 a[L:i] 是否满足要求。": "Enumerate the left endpoint L of the last subarray, transitioning from f[L] to f[i], checking if a[L:i] satisfies the condition.",
    "一般定义 f[i][j] 表示前缀 a[:i] 在状态 j 下的最优值。j 一般很小。": "Generally define f[i][j] as the optimal value for prefix a[:i] in state j. j is usually small.",
    "一般是中序遍历。": "Usually In-Order Traversal.",
    "视频讲解【基础算法精讲 11】": "Video Explanation [Core Algorithm Essentials 11]",
    "一般是刷表法。": "Usually the 'Push' DP method (updating future states from current).",
    "一般用来维护一段转移来源的最值。": "Usually used to maintain the maximum/minimum of a transition source range.",
    "一般要用到堆。": "Usually requires a Heap.",
    "上面都是和子串相关的算法，本节是和子序列相关的算法：子序列自动机。": "The above are substring-related algorithms. This section is for subsequences: Subsequence Automaton.",
    "虽然名字有些高大上，但实际上只是预处理 ≥i 的最近字母 c 的下标而已。": "The name sounds fancy, but it just precomputes the index of the nearest character 'c' after or at position i.",
    "见 讲解 中的「进阶问题」。": "See 'Advanced Problems' in the explanation.",
    "不会设计状态？那你可要好好刷这一节了。": "Can't design DP states? You need to practice this section carefully.",
    "不定长滑动窗口主要分为三类：求最长子数组，求最短子数组，求子数组个数。": "Variable-length sliding window has three types: Max Length, Min Length, and Count Subarrays.",
    "注：滑动窗口相当于在维护一个队列。右指针的移动可以视作入队，左指针的移动可以视作出队。": "Note: Sliding window is like maintaining a Queue. Right pointer moving = Enqueue, Left pointer moving = Dequeue.",
    "两个指针 left=0, right=n−1，从数组的两端开始，向中间移动，这叫相向双指针。上面的滑动窗口相当于同向双指针。": "Two pointers left=0, right=n-1 moving towards the middle is 'Opposite Direction Two Pointers'. Sliding window is 'Same Direction Two Pointers'.",
    "两个指针从数组中的同一个位置出发，一个向左，另一个向右，背向移动。": "Two pointers starting from the same position and moving outwards (back-to-back).",
    "两个指针的移动方向相同（都向右，或者都向左）。": "Two pointers moving in the same direction (both right or both left).",
    "个人觉得叫单调双端队列更准确。": "I think 'Monotonic Deque' is more accurate.",
    "单调队列 = 滑动窗口 + 单调栈。必须先掌握滑动窗口和单调栈这两个知识点，再学单调队列。": "Monotonic Queue = Sliding Window + Monotonic Stack. Master those two first.",
    "问：入队、出队、更新答案，这三步的顺序如何思考？": "Q: How to order Enqueue, Dequeue, and Update Answer?",
    "答：有两种情况。如果更新答案时，用到的数据包含当前元素，那么就需要先入队，再更新答案；如果用到的数据不包含当前元素，那么就需要先更新答案，再入队。至于出队，一般写在前面，每遍历到一个新的元素，就看看队首元素是否失效（不满足要求），失效则弹出队首。": "A: Two cases. If the answer depends on the current element, Enqueue -> Update. If not, Update -> Enqueue. Dequeue usually happens first: remove invalid elements from the front before accurate calculations.",
    "为什么堆化的时间复杂度是 O(n)？": "Why is Heapify time complexity O(n)?",
    "为方便大家练习，我把比较套路的贪心题目放在前面，更灵活的思维题和构造题放在后面。每个小节的题目均按照从易到难的顺序排列。": "For practice, standard greedy problems are first, followed by flexible thinking/constructive problems. Sorted by difficulty.",
    "如果做题时没有思路，推荐看看本文第五章的「思考清单」。": "If stuck, check the 'Thinking Checklist' in Chapter 5.",
    "也叫二次扫描法。": "Also called 'Two-Pass Scan' method.",
    "设 y 是 x 的子节点。从「以 x 为整棵树的根」变成「以 y 为整棵树的根」，发生了什么？": "Let y be a child of x. What happens when changing the root from x to y?",
    "也叫凸包优化/凸壳优化（CHT，Convex Hull Trick）。": "Also called Convex Hull Trick (CHT).",
    "也叫树上背包、依赖背包等。": "Also called Tree Knapsack or Dependency Knapsack.",
    "注：目前力扣只有无依赖的背包，时间复杂度为 O(nW2)。如果有依赖，可以优化到 O(nW)。": "Note: LeetCode only has dependency-free knapsack (O(nW^2)). With dependencies, it can be O(nW).",
    "二分的不是答案，而是一个和答案有关的值（间接值）。": "Binary search not on the answer itself, but on a value related to it (indirect value).",
    "交换论证法（exchange argument）用于证明一类贪心算法的正确性，也可以用来启发思考。做法如下：": "Exchange Argument is used to prove greedy correctness and inspire thinking. Method:",
    "从一般到特殊。": "From general to special.",
    "从小到大枚举回文数的模板（从 1 开始枚举）：": "Template to enumerate palindromes from small to large (starting from 1):",
    "从左到右扫一次，再从右到左扫一次。": "Scan once left-to-right, then once right-to-left.",
    "以下问题，设 n 是数组 a 的长度，m 是出现次数最多的元素的出现次数。": "In the following, n is array length, m is the frequency of the most frequent element.",
    "问题一：给定数组 a，能否重新排列其中的元素，使得所有相邻元素均不同？如果能，输出重排后的数组。": "Q1: Can we rearrange array a so no adjacent elements are equal? If yes, output the array.",
    "答：如果 m≤n−m+1，则可以做到，否则无法做到。": "A: Possible if m <= n - m + 1. Otherwise impossible.",
    "问题二：给定数组 a，每次操作，删除 a 中的两个不同元素。最多能操作多少次？": "Q2: Max operations if each operation removes two different elements?",
    "答：最多操作 min(⌊2n​⌋,n−m) 次。": "A: Max operations = min(floor(n/2), n - m).",
    "问题三：给定数组 a，每次操作，删除 a 中的至多两个不同元素。删除所有元素，最少要操作多少次？": "Q3: Min operations to remove all elements, deleting at most two different elements per op?",
    "答：最少操作 max(⌈2n​⌉,m) 次。": "A: Min operations = max(ceil(n/2), m).",
    "证明+具体操作方案": "Proof + Construction Strategy",
    "优先考虑最小/最大的数，从小到大/从大到小贪心。": "Prioritize min/max numbers; Greedy from small-to-large or large-to-small.",
    "如果答案与数组元素顺序无关，一般需要排序。排序后，可以遍历计算。": "If answer is independent of order, sort first. Then iterate.",
    "例如数组 [1,1,1,2,2]，其中第 1 小、第 2 小和第 3 小的数都是 1，第 4 小和第 5 小的数都是 2。": "E.g. [1,1,1,2,2], the 1st, 2nd, 3rd smallest are 1. 4th, 5th smallest are 2.",
    "前置题单：单调栈（矩形系列/字典序最小/贡献法）": "Prerequisite: Monotonic Stack (Rectangles / Lexicographically Smallest / Contribution)",
    "区间贪心有如下经典问题：": "Classic Interval Greedy problems:",
    "原理讲解：单调栈【基础算法精讲 26】": "Principle: Monotonic Stack [Core Algorithm Essentials 26]",
    "发生在前缀/后缀之间的转移，例如从 f[i−1] 转移到 f[i]，或者从 f[j] 转移到 f[i]。": "Transitions between prefix/suffix, e.g., f[i-1] -> f[i] or f[j] -> f[i].",
    "可以把树上问题转化成数组问题，比如子树的操作转化成子数组的操作。通常要结合其他数据结构。": "Tree problems can be converted to array problems (Subtree -> Subarray). Often combines with other data structures.",
    "可能算不上贪心，但为了题单的完整性，也放到这个分类中。": "Might not be strictly Greedy, but included for completeness.",
    "同一组内的物品至多/恰好选一个。": "Choose at most/exactly one item from each group.",
    "同上，从最小/最大的元素开始贪心。": "Same as above, greedy from min/max element.",
    "回想一下高考数学的最后一题，三个小问，前两小问让你计算一些特殊情况，第三小问让你计算/证明一个一般的结论。这其实就是从特殊到一般的思考方式，我们在做算法题（尤其是思维题和构造题）时，也可以从最简单、最特殊的情况开始，去探索题目的性质，逐渐过渡到一般情况。": "Recall math exam problems: first calculate special cases, then generalize. In algorithms (especially constructive ones), start from simple/special cases to discover properties, then generalize.",
    "图解：多重集组合数": "Visual: Multiset Combinations",
    "在「归」的过程中计算。": "Calculate during the 'Return' (Post-order) phase.",
    "如何灵活运用递归？【基础算法精讲 10】": "How to use Recursion flexibly? [Core Algorithm Essentials 10]",
    "在「递」的过程中维护值。": "Maintain values during the 'Forward' (Pre-order) phase.",
    "有些题目自顶向下和自底向上都可以做。有些题目也可以用 BFS 做。": "Some problems can be done Top-Down or Bottom-Up. Some also solvable by BFS.",
    "基于堆的反悔贪心。": "Regret Greedy based on Heap.",
    "子集和 DP（Sum Over Subsets DP，SOS DP），国内算法竞赛圈一般叫高维前缀和。": "Sum Over Subsets DP (SOS DP), also known as High-Dimensional Prefix Sum.",
    "原理讲解（方法二）": "Principle Explanation (Method 2)",
    "模板（从子集转移过来）：": "Template (Transition from Subsets):",
    "模板（从超集转移过来）：": "Template (Transition from Supersets):",
    "字典序的定义如下：": "Definition of Lexicographical Order:",
    "学习拓扑排序前，请先完成 1557. 可以到达所有点的最少点数目，有助于理解拓扑排序。": "Before Topological Sort, do 1557. Minimum Number of Vertices to Reach All Nodes.",
    "学习递归，从二叉树开始。": "Start learning Recursion with Binary Trees.",
    "晕递归的同学，请先看视频讲解【基础算法精讲 09】，欢迎点赞~": "Struggling with recursion? Watch [Core Algorithm Essentials 09].",
    "一般有三种遍历方式：": "Generally three traversal methods:",
    "完成本章后，请思考：什么时候要返回 f[n]，什么时候要返回 max(f)？": "After this chapter, think: When to return f[n] vs max(f)?",
    "定义循环左移操作：把字符串 s 的第一个字符 s[0] 移除，添加到 s 的末尾。例如 abcd 操作一次后得到 bcda。": "Define Cyclic Shift: Remove s[0] and append to end. 'abcd' -> 'bcda'.",
    "问题：你可以执行任意次循环左移操作，计算你能得到的字典序最小的字符串。": "Problem: Find the lexicographically smallest string obtainable by cyclic shifts.",
    "注：任意次循环左移操作后，得到的字符串叫做 s 的循环同构串。": "Note: Strings obtained by cyclic shifts are 'Cyclic Isomorphs'.",
    "推荐先完成 1163. 按字典序排在最后的子串，最小表示法是这题的环形版本。": "Recommend doing 1163. Last Substring in Lexicographical Order first. Minimum Representation is the cyclic version of it.",
    "对于 双变量问题，例如两数之和 ai​+aj​=t，可以枚举右边的 aj​，转换成 单变量问题，也就是在 aj​ 左边查找是否有 ai​=t−aj​，这可以用哈希表维护。": "For Two-Variable problems (e.g. ai+aj=t), enumerate the right variable aj to convert to a Single-Variable problem: Find ai=t-aj to the left (using Hash Table).",
    "我把这个技巧叫做 枚举右，维护左。": "I call this technique 'Enumerate Right, Maintain Left'.",
    "下面这些题目，如果可以，请用一次遍历实现。": "Solve these with one pass if possible.",
    "对于一些二维 DP（例如背包、最长公共子序列），如果把 DP 矩阵画出来，其实状态转移可以视作在网格图上的移动。所以在学习相对更抽象的二维 DP 之前，做一些形象的网格图 DP 会让后续的学习更轻松（比如 0-1 背包的空间优化写法为什么要倒序遍历）。": "For 2D DP (Knapsack, LCS), visualizing the DP matrix shows transitions as grid movements. Grid DP helps understand abstract 2D DP (e.g., why 0-1 Knapsack space optimization needs reverse iteration).",
    "对于无法排序的题目，尝试从左到右/从右到左贪心。思考第一个数/最后一个数的贪心策略，把 n 个数的原问题转换成 n−1 个数（或更少）的子问题。": "If sorting isn't possible, try Greedy Left-to-Right or Right-to-Left. Think about the strategy for the first/last element to reduce n to n-1.",
    "读者可以对比下面的题目和 动态规划题单 中的线性 DP、状态机 DP 的区别，思考什么情况下只能 DP 不能贪心，从而加深对「局部最优」和「全局最优」的理解。": "Contrast these with Linear/State Machine DP. Think when you MUST use DP vs Greedy to understand 'Local vs Global Optimum'.",
    "对于有三个或者四个变量的问题，枚举中间的变量往往更好算。": "For 3 or 4 variables, enumerating the middle variable is often easier.",
    "为什么？比如问题有三个下标，需要满足 0≤i<j<k<n，对比一下：": "Why? E.g. 0<=i<j<k<n, compare:",
    "对于类似合法括号字符串（RBS）的消除问题，通常根据题意，会有如下性质：": "For Regular Bracket String (RBS) elimination problems, properties usually include:",
    "将数组分成（恰好/至多）k 个连续子数组，计算与这些子数组有关的最优值。": "Split array into (exactly/at most) k subarrays, optimize a value related to them.",
    "一般定义 f[i][j] 表示将长为 j 的前缀 a[:j] 分成 i 个连续子数组所得到的最优解。": "Generally define f[i][j] as optimal solution splitting prefix a[:j] into i subarrays.",
    "枚举最后一个子数组的左端点 L，从 f[i−1][L] 转移到 f[i][j]，并考虑 a[L:j] 对最优解的影响。": "Enumerate left endpoint L of the last subarray, transition from f[i-1][L] to f[i][j], adding effect of a[L:j].",
    "注：对于恰好型划分 DP，可以通过控制内层循环的上下界，把时间复杂度从 O(nk) 优化至 O((n−k)k)。例如 3473 题。": "Note: For 'Exactly k' DP, optimize complexity from O(nk) to O((n-k)k) by controlling loop bounds. E.g. Problem 3473.",
    "属于离线算法的一种。": "A type of Offline Algorithm.",
    "左闭右开公式：子数组 [left,right) 的元素和为 sum[right]−sum[left]。把下标区间定义成左闭右开，就不需要加一减一了。": "Left-Closed Right-Open formula: Subarray [left, right) sum = sum[right] - sum[left]. Avoids +1/-1 errors.",
    "差分与前缀和的关系，类似导数与积分的关系。": "Difference Array vs Prefix Sum is like Derivative vs Integral.",
    "数组 a 的差分的前缀和就是数组 a（不变）。": "The Prefix Sum of the Difference Array of A is A itself.",
    "带权树 LCA 模板（节点编号从 0 开始）：": "Weighted Tree LCA Template (0-indexed):",
    "快速幂、组合数的预处理模板见 模运算的世界：当加减乘除遇上取模": "Fast Pow / Combinatorics Templates: See 'World of Modular Arithmetic'.",
    "我们可以判断 n 能否能被 n​ 以内的某个大于 1 的整数整除，如果不能则说明 n 是质数。为什么？": "We verify primality by checking divisibility up to sqrt(n). Why?",
    "反证法：如果 n 不能被 n​ 以内的（大于 1 的）整数整除，但可以被大于 n​ 的整数 d 整除，那么必然还有一个数 dn​ 也能整除 n。但是 dn​<n​n​=n​，说明存在一个 n​ 以内的（大于 1 的）整数能整除 n，矛盾。": "Proof by contradiction: If n is divisible by d > sqrt(n), result n/d must be < sqrt(n). So a factor < sqrt(n) must exist.",
    "注意 1 不是质数。": "Note: 1 is not a prime.",
    "更快的模板（写法二）": "Faster Template (Method 2)",
    "找连通块、判断是否有环（如 207 题）等。部分题目做法不止一种。": "Find Connected Components, detect cycles (e.g. 207). Multiple methods often exist.",
    "模板（计算每个连通块的大小）：": "Template (Calculate size of each connected component):",
    "把任意区间用 O(logn) 个区间表示，线段树的每个节点记录对应区间的信息。": "Represent any interval with O(logn) intervals. Segment Tree nodes store interval info.",
    "把拓扑排序想象成一个黑盒，给它一堆杂乱的先修课约束，它会给你一个井井有条的课程学习安排。": "Think of Topological Sort as a black box: Input messy prerequisites, Output valid schedule.",
    "这一种在图上的「排序」，可以把杂乱的点排成一排。前提条件是图中无环，从而保证每条边都是从排在前面的点，指向排在后面的点。即对于任意有向边 x→y，x 一定在 y 之前。": "It sorts graph nodes linearly. Precondition: No cycles (DAG). For edge x->y, x comes before y.",
    "把数组/字符串划分成满足要求的若干段，最小化/最大化划分的段数。": "Partition array/string into valid segments, minimize/maximize segment count.",
    "思考方法同上，尝试从左到右/从右到左贪心。": "Same thinking: Greedy Left-to-Right or Right-to-Left.",
    "读者可以对比下面的题目和 动态规划题单 中的划分型 DP 的区别，思考什么情况下只能 DP 不能贪心，从而加深对「局部最优」和「全局最优」的理解。": "Compare with Partition DP. Think when DP is mandatory to understand Local vs Global Optimum.",
    "把最多选 k 个物品的问题（时间复杂度高）转换成选任意个物品的问题（时间复杂度低）。": "Convert 'At most k items' (high complexity) to 'Any number of items' (low complexity).",
    "一般时间复杂度为 O(nlogU) 或者 O(nlogn)。": "Complexity usually O(n log U) or O(n log n).",
    "把状态抽象成图上的点，用 BFS 遍历这张图，计算从初始状态到目标状态的最短路长度。": "Abstract states as graph nodes, use BFS to find shortest path from Start to Target.",
    "可以锻炼状态设计能力。": "Good for practicing state design.",
    "掌握动态规划（DP）是没有捷径的，咱们唯一能做的，就是投入时间猛猛刷题。好比学数学，只看书看视频而不做习题，是不能说学会的。": "No shortcuts for DP. You must practice. Like math: watching videos isn't enough.",
    "我能做的，是帮你节省找题的时间，并把这些题分类整理好。有着相同套路的题，一起做效率会更高，也更能领悟到 DP 的精髓。每个小节的题目已按照难度分排序（右侧数字为难度分）。": "I save you time by curating/categorizing problems. Solving similar patterns together is efficient. Problems sorted by difficulty rating.",
    "记忆化搜索是新手村神器（甚至可以用到游戏后期），推荐先看 动态规划入门：从记忆化搜索到递推。": "Memoization is great for beginners (and experts). Recommend 'DP Intro: From Memoization to Iteration'.",
    "但记忆化搜索并不是万能的，某些题目只有写成递推，才能结合数据结构等来优化时间复杂度，多数题目还可以优化空间复杂度。所以尽量在写完记忆化搜索后，把递推的代码也写一下。熟练之后直接写递推也可以。": "Memoization isn't magic. Iteration allows further optimizations (time/space). Try to write iterative code after memoization.",
    "有时候，思考「最后一步发生了什么」能启发我们找到子问题，进而得到状态定义和状态转移方程。": "Thinking 'What happened in the last step' often reveals subproblems and state transitions.",
    "推荐先阅读：从集合论到位运算，常见位运算技巧分类总结！": "Read first: Set Theory to Bitwise Operations, Common Techniques Summary!",
    "支持删除堆中任意元素。": "Supports deleting any element from Heap.",
    "数位 DP v1.0 模板讲解": "Digit DP v1.0 Template Explanation",
    "数位 DP v2.0 模板讲解（上下界数位 DP）": "Digit DP v2.0 Template Explanation (Lower/Upper Bound)",
    "下面是数位 DP v2.1 模板。相比 v2.0，不需要写 isNum 参数。": "Digit DP v2.1 Template. Unlike v2.0, 'isNum' is not needed.",
    "注：只有上界约束的题目，相当于 low=0 或者 low=1。": "Note: Problems with only upper bound imply low=0 or low=1.",
    "有两种做法：": "Two approaches:",
    "有两种基本贪心策略：": "Two basic greedy strategies:",
    "有两种类型的矩阵快速幂优化 DP：": "Two types of Matrix Exponentiation Optimization for DP:",
    "本文全面整理了力扣上的数学相关题目，其中数论和组合数学的题目比较多。": "Comprehensive compilation of Math problems on LeetCode (mostly Number Theory / Combinatorics).",
    "部分题目（尤其是组合数学）会涉及到取模，我写了一篇详细的取模教程，请看 模运算的世界：当加减乘除遇上取模。": "Some problems involve modulo. See my tutorial: 'The World of Modular Arithmetic'.",
    "本质上和不相交区间是一样的。": "Essentially the same as Non-overlapping Intervals.",
    "本质上就是排列型 ②。": "Essentially Permutation Type 2.",
    "本质是二分答案求最大。二分的 mid 表示下界。": "Essentially Binary Search for Max. 'mid' represents the lower bound.",
    "本质是二分答案求最小。二分的 mid 表示上界。": "Essentially Binary Search for Min. 'mid' represents the upper bound.",
    "好比用一个盖子（上界）去压住最大值，看看能否压住（check 函数）。": "Like using a lid (upper bound) to press down the max value. Check if it fits.",
    "本质是搜索树上的 DFS。": "Essentially DFS on a Search Tree.",
    "推荐先完成 §2.7 节。先理解二叉树上的回溯，再来学习一般情况下的回溯。": "Do §2.7 first. Understand Binary Tree Backtracking before General Backtracking.",
    "本质是模 2 剩余系的加法。": "Essentially addition in Modulo-2 Residue System (XOR).",
    "本质是相向双指针。": "Essentially Opposite Direction Two Pointers.",
    "本题单的大多数题目都可以用字符串哈希解决。": "Most problems here can be solved by String Hash.",
    "推荐先把 2156. 查找给定哈希值的子串 和 3756. 连接非零数字并乘以其数字和 II 做了，对理解多项式哈希的计算方法有帮助。": "Recommend 2156 and 3756 first to understand Polynomial Rolling Hash.",
    "模板代码见 我的题解，包含单模哈希和双模哈希。": "Template code in my solution (includes Single and Double Modulo Hash).",
    "小技巧：我们可以用字符串哈希比较两个子串的字典序大小。做法是二分长度，计算最长公共前缀（LCP），然后比较 LCP 的下一个字母。时间复杂度：O(logn)。见 3722 题。": "Tip: Compare substring lexicographical order using String Hash. Binary search length for LCP, then compare next char. Time: O(logn). See 3722.",
    "构造题会给定一些约束，我们要构造一个满足这些约束的数组/字符串等。": "Constructive problems ask to build an array/string meeting constraints.",
    "思考方式和第五章的「思考清单」是一样的，在特殊情况中寻找灵感。": "Thinking process is like Chapter 5 'Checklist': Find inspiration in special cases.",
    "枚举题目的其中一个变量，将其视作已知条件，然后在此基础上贪心。": "Enumerate one variable, treat it as known, then Greedy.",
    "也可以枚举答案，检查是否可以满足要求。（类似二分答案）": "Or enumerate the answer and check validity (like Binary Search on Answer).",
    "栅栏问题：长为 n 米的篱笆栅栏，围成一个矩形，矩形面积最大是多少？": "Fence Problem: Maximize area of rectangle with perimeter n.",
    "变形：长为 n 米的栅栏分成 k 份，每份围成一个正方形，面积之和最小是多少？": "Variation: Split n meters into k parts, form k squares. Minimize total area?",
    "模板一，预处理每个数的所有不同质因子。原理同埃氏筛。": "Template 1: Precompute distinct prime factors (Sieve of Eratosthenes style).",
    "模板二，预处理 x 的最小质因子 LPF(x)，从而做到 O(logx) 分解 x。可以求出 x 的每个质因子的个数。": "Template 2: Precompute Lowest Prime Factor LPF(x) for O(log x) factorization.",
    "模板（交替染色法）：": "Template (Alternating Coloring / Bipartite Check):",
    "模板（埃氏筛）：": "Template (Sieve of Eratosthenes):",
    "模板（最大异或和）：": "Template (Max XOR Sum):",
    "模板（预处理每个数的所有因子）：": "Template (Precompute all factors):",
    "每个元素 x 都有一个相应的价值 f(x)，计算 [low,high] 中的满足题目约束的元素的价值总和。": "Each x has value f(x). Calculate total value of valid elements in [low, high].",
    "例如 f(x)=x 是计算满足题目约束的元素和，f(x)=digsum(x) 是计算满足题目约束的元素的数位和。": "E.g. f(x)=x for sum of elements, f(x)=digsum(x) for sum of digits.",
    "模板（数位和）：": "Template (Digit Sum):",
    "每个物品只能选一次，即要么选，要么不选。所以 0-1 背包是「选或不选」的代表。": "Each item picked at most once. 0-1 Knapsack represents 'Pick or Not'.",
    "关于「枚举选哪个」的代表，见本题单的「§4.2 最长递增子序列」。": "For 'Enumerate Which to Pick', see '§4.2 LIS'.",
    "求最短路等。要求边权都是 1（或者说都是同一个正数）。": "Shortest path, etc. Requires edge weights to be 1 (or same positive value).",
    "模板（单源最短路）：": "Template (Single Source Shortest Path):",
    "注意这些题目和回溯的区别，某些回溯题目要求输出所有方案，这里只要求输出一个。": "Note diff from Backtracking: Backtracking outputs ALL solutions, this outputs ONE.",
    "注：可能有同学觉得树形 DP 没有重复访问同一个状态（重叠子问题），并不能算作 DP，而是算作普通的递归。这么说也有一定道理，不过考虑到思维方式和 DP 是一样的自底向上，所以仍然叫做树形 DP。此外，如果是自顶向下的递归做法，是存在重叠子问题的，一般要结合记忆化搜索实现。": "Note: Some argue Tree DP isn't DP (no overlapping subproblems), just recursion. But the Bottom-Up thinking aligns with DP. Top-Down recursion does have overlapping subproblems (Memoization needed).",
    "注：在国内算法竞赛圈，这个算法也叫扩展 KMP。": "Note: Known as 'Extended KMP' in Chinese CP circle.",
    "对于字符串 s，定义 z[i] 表示后缀 s[i:] 与 s 的 LCP（最长公共前缀）的长度，其中 s[i:] 表示从 s[i] 到 s[n−1] 的子串。": "Def z[i] as LCP of suffix s[i:] and s.",
    "常用技巧是构造字符串 pattern+s，如果发现 z[m+i]≥m（m 是 pattern 的长度），则说明从 s[i] 开始的子串与 pattern 匹配。": "Trick: Construct 'pattern+s'. If z[m+i] >= m, pattern matches at s[i].",
    "所以上面的一些 KMP 题目（子串匹配相关的），也可以用 Z 函数解决。读者可以尝试用 Z 函数解决 28. 找出字符串中第一个匹配项的下标。": "So KMP problems can be solved by Z-Algorithm. Try LeetCode 28 with Z-Algo.",
    "注：由于周赛中的链表题可以转成数组处理，难度比直接处理链表低，故不标明难度分。": "Note: Weekly Contest Linked List problems can be converted to Array (easier), so no difficulty rating.",
    "带着问题去做下面的题目：": "Solve while thinking about:",
    "注：部分题目可以不用栈，而是用一个数字记录嵌套深度。": "Note: Some solvable with just a depth counter, no Stack needed.",
    "涉及到 Hierholzer 算法。": "Involves Hierholzer's Algorithm.",
    "涉及到 Kruskal 算法和 Prim 算法。前者一般用于稀疏图，后者一般用于稠密图。": "Involves Kruskal (Sparse) and Prim (Dense).",
    "注：如果要求最大生成树，把边权从大到小排序。": "Note: For Max Spanning Tree, sort edges distinct.",
    "Kruskal 算法模板（用到了并查集，完整模板见 数据结构题单）：": "Kruskal Template (uses Union-Find, see DS topic):",
    "涉及到 Tarjan 算法。": "Involves Tarjan's Algorithm.",
    "物品可以重复选，无个数限制。": "Items can be picked repeatedly (unlimited).",
    "物品可以重复选，有个数限制。": "Items can be picked repeatedly (limited).",
    "注意求方案数的题目不能用二进制优化。比如从 6 个相同物品中选 3 个，只有一种选法。但按照二进制优化，会把 6 分解为 1+2+3，有 1+2 和 3 两种选法。": "Note: Counting problems can't use Binary Optimization. E.g. Choosing 3 from 6 identical items is 1 way. Binary optimization (1+2+3) incorrectly counts 1+2 vs 3 as distinct.",
    "如果要优化，可以考虑用 同余前缀和 优化。": "To optimize, consider 'Congruence Prefix Sum'.",
    "由于有其他做法（比如状压 DP），难度分仅供参考。": "Difficulty ref only (other methods like Bitmask DP exist).",
    "知道大概怎么做，但不好实现的题目。部分题目是模拟题。": "Known approach but hard implementation. Some are Simulation.",
    "线段树本质是二叉树，在学习之前，建议先做做 104. 二叉树的最大深度 和 111. 二叉树的最小深度（自底向上写法），当作热身。": "Segment Tree is a Binary Tree. Warm up with 104 (Max Depth) and 111 (Min Depth, Bottom-Up).",
    "线段树：为什么要这样设计？ 理解线段树发明的动机。": "Segment Tree: Why design it this way? Understand the motivation.",
    "给定两个长度均为 n 的数组 a 和 b，可以交换同一数组内的元素，最小化/最大化": "Given arrays a, b (len n). Swapping allowed within array. Minimize/Maximize...",
    "把 a 和 b 都从小到大排序，可以最大化上式。": "Sort both a and b ascending to Maximize.",
    "把 a 从小到大排序，b 从大到小排序，可以最小化上式。": "Sort a ascending, b descending to Minimize.",
    "给定数组 nums，每次操作可以把其中一个数加一或者减一。把 nums 的所有数都变成一样的，最少要操作多少次？": "Given nums, op: +1 or -1. Min ops to make all equal?",
    "把所有数都变成 nums 的中位数是最优的。": "Targeting the Median is optimal.",
    "能用树状数组解决的题目，也能用线段树解决（反过来不一定）。但树状数组实现简单，代码短。": "BIT problems are solvable by Segment Tree (not vice versa). BIT is simpler/shorter.",
    "为方便大家练习，我把适合用树状数组解决的题目分到树状数组中，其余分到线段树中。": "BIT-suitable problems are categorized under BIT, others under Segment Tree.",
    "英文名 meet in the middle。": "English: Meet-in-the-middle.",
    "讲解（见文末）": "Explanation (see end)",
    "见 位运算题单。": "See 'Bit Manipulation' Topic.",
    "见 单调栈题单。": "See 'Monotonic Stack' Topic.",
    "见 图论题单 中的「§3.1 单源最短路：Dijkstra 算法」，我标记了网格图的题目。": "See 'Graph' Topic §3.1 Dijkstra (Grid problems marked).",
    "见 数据结构题单 中的「§3.4 合法括号字符串」。": "See 'Data Structures' Topic §3.4 Valid Parentheses.",
    "见 链表、树、回溯 题单的第三章节。": "See Chapter 3 of 'Linked List, Tree, Backtracking'.",
    "视频讲解【基础算法精讲 06】": "Video Explanation [Core Algorithm Essentials 06]",
    "视频讲解【基础算法精讲 07】": "Video Explanation [Core Algorithm Essentials 07]",
    "视频讲解【基础算法精讲 08】": "Video Explanation [Core Algorithm Essentials 08]",
    "视频讲解【基础算法精讲 12】": "Video Explanation [Core Algorithm Essentials 12]",
    "视频讲解【基础算法精讲 13】": "Video Explanation [Core Algorithm Essentials 13]",
    "视频讲解【基础算法精讲 14】": "Video Explanation [Core Algorithm Essentials 14]",
    "把分割线（逗号）看成是可以「选或不选」的东西，本质是子集型回溯。": "Treat separator (comma) as 'Select or Not'. Essentially Subset Backtracking.",
    "有「选或不选」和「枚举选哪个」两种写法。": "Two styles: 'Select or Not' vs 'Enumerate Which'.",
    "也可以用二进制枚举做。": "Can also use Binary Enumeration.",
    "视频讲解【基础算法精讲 15】": "Video Explanation [Core Algorithm Essentials 15]",
    "有个数上的约束。也算作子集型回溯。": "Has count constraint. Also Subset Backtracking.",
    "视频讲解【基础算法精讲 16】": "Video Explanation [Core Algorithm Essentials 16]",
    "部分题目也可以用状压 DP 做。": "Some solvable by Bitmask DP.",
    "视频讲解【基础算法精讲 23】": "Video Explanation [Core Algorithm Essentials 23]",
    "计算合法子序列的最长长度、个数、元素和等。": "Calc valid subsequence max length, count, sum, etc.",
    "一般定义 f[x] 表示以元素 x 结尾的合法子序列的最长长度/个数/元素和，从子序列的倒数第二个数转移过来。": "Generally define f[x] as result ending with element x. Transition from second-to-last element.",
    "注意这里的 x 不是下标，是元素值。如果 x 不是整数，或者值域范围很大，可以用哈希表代替数组。": "Note x is value, not index. If x not integer or huge range, use Hash Table.",
    "计算最少（最多）可以划分出多少段、最优划分得分等。": "Min/Max segments, optimal partition score, etc.",
    "一般定义 f[i] 表示长为 i 的前缀 a[:i] 在题目约束下，分割出的最少（最多）子数组个数（或者定义成分割方案数）。": "Generally define f[i] max/min segments for prefix a[:i].",
    "讲解【基础算法精讲 21】": "Explanation [Core Algorithm Essentials 21]",
    "讲解：0-1 背包 完全背包【基础算法精讲 18】": "Explanation: 0-1 & Unbounded Knapsack [Core Algorithm Essentials 18]",
    "讲解：二分查找 红蓝染色法【基础算法精讲 04】": "Explanation: Binary Search Red-Blue Coloring [Core Algorithm Essentials 04]",
    "设 nums 为递增（非递减）数组，长为 n。": "Let nums be increasing (non-decreasing), length n.",
    "注意 <x 和 ≥x 互为补集，元素个数之和为 n。≤x 和 >x 同理。": "Note <x and >=x are complements (sum to n). Same for <=x and >x.",
    "讲解：区间 DP【基础算法精讲 22】": "Explanation: Interval DP [Core Algorithm Essentials 22]",
    "从数组的左右两端不断缩短，求解关于某段下标区间的最优值。": "Shrink from both ends to solve for sticky index interval.",
    "一般定义 f[i][j] 表示下标区间 [i,j] 的最优值。": "Generally define f[i][j] as optimal value for interval [i, j].",
    "讲解：带你发明树状数组！附数学证明": "Explanation: Inventing BIT! With Proof.",
    "讲解：最长公共子序列 编辑距离【基础算法精讲 19】": "Explanation: LCS & Edit Distance [Core Algorithm Essentials 19]",
    "一般定义 f[i][j] 表示对 (s[:i],t[:j]) 的求解结果。": "Generally define f[i][j] for result of (s[:i], t[:j]).",
    "讲解：最长递增子序列【基础算法精讲 20】": "Explanation: LIS [Core Algorithm Essentials 20]",
    "做法有很多：": "Many approaches:",
    "讲解：树形 DP：打家劫舍 III【基础算法精讲 24】": "Explanation: Tree DP: House Robber III [Core Algorithm Essentials 24]",
    "讲解：树形 DP：树的直径【基础算法精讲 23】": "Explanation: Tree DP: Tree Diameter [Core Algorithm Essentials 23]",
    "讲解：树形 DP：监控二叉树【基础算法精讲 25】，包含 968 的变形题。": "Explanation: Tree DP: Camera Binary Tree [Core Algorithm Essentials 25].",
    "贪心、脑筋急转弯等。": "Greedy, Brain Teaser, etc.",
    "边权只有 0 和 1 的题目，也可以用 BFS 做。": "0-1 Edge Weights -> 0-1 BFS.",
    "适用于需要计算最短距离（最短路）的题目。": "For Shortest Path problems.",
    "DFS 是不撞南墙不回头；BFS 是往水塘中扔石头（起点），荡起一圈圈涟漪（先访问近的，再访问远的）。": "DFS: Hit the wall before turning. BFS: Throw stone in pond, ripples spread (Near before Far).",
    "适用于需要计算连通块个数、大小的题目。": "For Connected Components count/size.",
    "部分题目做法不止一种，也可以用 BFS 或并查集解决。": "Alternative methods: BFS, Union-Find.",
    "二叉树 DFS 与网格图 DFS 的区别：": "Diff between Binary Tree DFS and Grid DFS:",
    "适用场景：按照题目要求，数组会被分割成若干组，每一组的判断/处理逻辑是相同的。": "Scenario: Array split into groups, each processed identically.",
    "通常要用到「枚举右，维护左」的技巧（见本题单 §0.1 节）。": "Often uses 'Enumerate Right, Maintain Left' (see §0.1).",
    "通过改变回答询问的顺序，使问题更容易处理。": "Modify query order to simplify processing.",
    "相应的，在线算法就是按照 queries 的顺序一个一个处理。": "Correspondingly, Online Algo processes queries in order.",
    "部分语言的标准库没有 GCD 和 LCM，需要手写。推荐写迭代，比递归快一点。": "Some std libs lack GCD/LCM. Write Iterative (faster than recursive).",
    "部分题目也出现在其他贪心分类中，为了题单的完整性整理到一起。": "Some duplicates from other Greedy sections (for completeness).",
    "部分题目也可以用 BFS 解决。": "Solvable by BFS.",
    "部分题目也可以用二分解决。": "Solvable by Binary Search.",
    "部分题目也可以用状态机 DP 解决。": "Solvable by State Machine DP.",
    "如果涉及到的只是若干元素，而不是前缀/后缀这样的一段元素，也可以用「枚举右，维护左」思考，详见数据结构题单。": "If about elements (not ranges), try 'Enumerate Right, Maintain Left' (see DS topic).",
    "部分题目也可以用珂朵莉树解决。": "Solvable by ODT (Chtholly Tree).",
    "部分题目也可以用试填法解决。": "Solvable by Trial method.",
    "部分题目有其他解法，难度分仅供参考。": "Other solutions exist, difficulty ref only.",
    "部分题目需要先排序，然后在有序数组上二分查找。": "Sort first, then Binary Search.",
    "部分题目需要结合懒删除堆。": "Lazy Deletion Heap required.",
    "做法不止一种，部分题目也可以用有序集合/权值树状数组等数据结构解决。": "Multiple methods: Ordered Set, Value BIT, etc.",
    "问：贪心和 DP 的区别是什么？": "Q: Diff between Greedy and DP?",
    "答：DP 可以视为带记忆化的暴力搜索，只要不遗漏任何分支，答案一定是对的。贪心可以视为带剪枝的搜索，如果贪心策略不对，就容易贪过头，把正确的分支给剪掉。": "A: DP = Memoized Brute Force (Complete). Greedy = Pruned Search (Risky, might prune correct branch).",
    "问：有没有万能方法，判断一道题是贪心还是 DP？": "Q: Universal way to distinguish Greedy vs DP?",
    "答：很难。如果不知道题目类型，把 DP 想成贪心的大有人在。我的建议是先思考 DP 能不能做，再思考贪心。如果 DP 的时间复杂度足以通过题目，就不用思考贪心策略了。": "A: Hard. Suggestion: Try DP first. If DP complexity fits, use it. Then try Greedy.",
    "此外，这也说明按照题单刷题的缺点：提前知道题目类型，跳过了一些思考步骤。如何弥补这个缺点？请看 如何科学刷题。": "This shows weakness of Topic Lists: Spoilers. See 'How to Practice Scientifically'.",
    "队列常用在 BFS 中，见 网格图题单 和 图论题单。与此相比，栈常用在 DFS 中，但无需我们手动维护。": "Queue used in BFS (Grid/Graph). Stack used in DFS (implicit via recursion).",
    "除了可以用树状数组解决，部分题目也可以在归并排序的同时计算。": "Besides BIT, can be solved during Merge Sort.",
    "题目求什么，就二分什么。": "Binary Search whatever the problem asks for."
}